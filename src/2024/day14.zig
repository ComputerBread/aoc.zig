const std = @import("std");
const mem = std.mem;

input: []const u8,
allocator: mem.Allocator,

pub fn part1(this: *const @This()) !?i64 {
    var tl: i64 = 0;
    var tr: i64 = 0;
    var bl: i64 = 0;
    var br: i64 = 0;
    const g = @Vector(2, i64){ 101, 103 };
    const time = @Vector(2, i64){ 100, 100 };

    var lines = mem.tokenizeScalar(u8, this.input, '\n');
    while (lines.next()) |line| {
        var it = mem.tokenizeScalar(u8, line, ' ');
        var pit = mem.tokenizeScalar(u8, it.next().?[2..], ',');
        var vit = mem.tokenizeScalar(u8, it.next().?[2..], ',');
        const p = @Vector(2, i64){ try std.fmt.parseInt(i64, pit.next().?, 10), try std.fmt.parseInt(i64, pit.next().?, 10) };
        const v = @Vector(2, i64){ try std.fmt.parseInt(i64, vit.next().?, 10), try std.fmt.parseInt(i64, vit.next().?, 10) };
        const n = @mod((time * v + p), g);
        if (n[0] < 50 and n[1] < 51) {
            tl += 1;
        } else if (n[0] > 50 and n[1] < 51) {
            tr += 1;
        } else if (n[0] < 50 and n[1] > 51) {
            bl += 1;
        } else if (n[0] > 50 and n[1] > 51) {
            br += 1;
        }
    }

    // const p = @Vector(2, i32){ 2, -3 };
    // const v = @Vector(2, i32){ 2, -3 };
    // const g = @Vector(2, i32){ 11, 7 };
    // for (0..5) |i| {
    //     const time = @Vector(2, i32){ @intCast(i), @intCast(i) };
    //     const n = @mod((time * v + p), g);
    //     std.debug.print("{d} sec, pos: {}", .{ i, n });
    // }
    return tl * tr * br * bl;
}

pub fn gridToPbm(grid: *[103][101]bool, output_path: []const u8) !void {
    // Validate grid dimensions
    if (grid.len != 103 or grid[0].len != 101) {
        return error.InvalidGridDimensions;
    }

    const width = 101;
    const height = 103;

    // Open file for writing
    const file = try std.fs.cwd().createFile(output_path, .{});
    defer file.close();

    // Write PBM header
    const writer = file.writer();
    try writer.print("P1\n# Generated by Zig\n{d} {d}\n", .{ width, height });

    // Write pixel data
    var y: usize = 0;
    while (y < height) : (y += 1) {
        var x: usize = 0;
        while (x < width) : (x += 1) {
            // Print 0 for black, 1 for white
            const pixel = grid[y][x];
            try writer.print("{d}{s}", .{ @intFromBool(pixel), if (x == width - 1) "\n" else " " });
        }
    }
}

pub fn part2(this: *const @This()) !?i64 {
    const robotCount: i64 = 500;

    var pos = [_]@Vector(2, i64){@Vector(2, i64){ 0, 0 }} ** robotCount;
    var vel = [_]@Vector(2, i64){@Vector(2, i64){ 0, 0 }} ** robotCount;

    var lines = mem.tokenizeScalar(u8, this.input, '\n');
    var count: usize = 0;
    while (lines.next()) |line| : (count += 1) {
        var it = mem.tokenizeScalar(u8, line, ' ');
        var pit = mem.tokenizeScalar(u8, it.next().?[2..], ',');
        var vit = mem.tokenizeScalar(u8, it.next().?[2..], ',');
        const p = @Vector(2, i64){ try std.fmt.parseInt(i64, pit.next().?, 10), try std.fmt.parseInt(i64, pit.next().?, 10) };
        const v = @Vector(2, i64){ try std.fmt.parseInt(i64, vit.next().?, 10), try std.fmt.parseInt(i64, vit.next().?, 10) };

        pos[count] = p;
        vel[count] = v;
    }

    var i: i64 = 0;
    const g = @Vector(2, i64){ 101, 103 };
    const file = try std.fs.cwd().createFile("sol-d14.txt", .{ .read = true });
    defer file.close();
    // row = y, col = x
    while (i < (101 * 103)) : (i += 1) {
        var grid = [_][101]bool{[_]bool{false} ** 101} ** 103;

        // update pos & print them
        const time = @Vector(2, i64){ i, i };
        for (pos, vel) |p, v| {
            const n = @mod((time * v + p), g);
            grid[@intCast(n[1])][@intCast(n[0])] = true;
        }
        var buf = [_]u8{0} ** 30;
        const read = try std.fmt.bufPrint(&buf, "d14-{d}.bmp", .{i});
        std.debug.print("{s}\n", .{read});
        // try gridToPbm(&grid, read);
    }

    // after looking, sol is 7572
    return 7572;
}

pub fn part3(this: *const @This()) !?i64 {
    const robotCount: i64 = 500;

    var pos = [_]@Vector(2, i64){@Vector(2, i64){ 0, 0 }} ** robotCount;
    var vel = [_]@Vector(2, i64){@Vector(2, i64){ 0, 0 }} ** robotCount;

    var lines = mem.tokenizeScalar(u8, this.input, '\n');
    var count: usize = 0;
    while (lines.next()) |line| : (count += 1) {
        var it = mem.tokenizeScalar(u8, line, ' ');
        var pit = mem.tokenizeScalar(u8, it.next().?[2..], ',');
        var vit = mem.tokenizeScalar(u8, it.next().?[2..], ',');
        const p = @Vector(2, i64){ try std.fmt.parseInt(i64, pit.next().?, 10), try std.fmt.parseInt(i64, pit.next().?, 10) };
        const v = @Vector(2, i64){ try std.fmt.parseInt(i64, vit.next().?, 10), try std.fmt.parseInt(i64, vit.next().?, 10) };

        pos[count] = p;
        vel[count] = v;
    }

    var i: i64 = 0;
    const stdin = std.io.getStdIn().reader();
    const stdout = std.io.getStdOut().writer();
    var buf = [_]u8{0} ** 10;
    var writer = std.io.fixedBufferStream(&buf);
    const g = @Vector(2, i64){ 101, 103 };
    // row = y, col = x
    while (true) : (i += 1) {
        try stdin.streamUntilDelimiter(writer.writer(), '\n', 10);
        if (buf[0] == 'a') {
            break;
        }
        var grid = [_][101]u8{[_]u8{' '} ** 101} ** 103;

        // update pos & print them
        const time = @Vector(2, i64){ i, i };
        for (pos, vel) |p, v| {
            const n = @mod((time * v + p), g);
            grid[@intCast(n[1])][@intCast(n[0])] = '#';
        }
        for (0..103) |y| {
            for (0..101) |x| {
                try stdout.print("{c}", .{grid[y][x]});
            }
            try stdout.print("\n", .{});
        }
        try stdout.print("time: {d}\n", .{i});
    }

    return i;
}

test "it should do nothing" {
    const allocator = std.testing.allocator;
    const input = "";

    const problem: @This() = .{
        .input = input,
        .allocator = allocator,
    };

    try std.testing.expectEqual(null, try problem.part1());
    try std.testing.expectEqual(null, try problem.part2());
}
